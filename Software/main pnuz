#include <Arduino.h>

// Pin definitions
const int MOTOR_A_STEP_PIN = 11;
const int MOTOR_A_DIR_PIN = 12;
const int MOTOR_B_STEP_PIN = 13;
const int MOTOR_B_DIR_PIN = 14;
const int Z_SOLENOID_PIN = 15; // Solenoid valve for pneumatic cylinder
const int SPINDLE_PIN = 16;

// Limit switch pins
const int X1_LIMIT_PIN = 0;
const int Y1_LIMIT_PIN = 1;
const int X2_LIMIT_PIN = 2;
const int Y2_LIMIT_PIN = 3;

// Motion parameters
float currentX = 0.0, currentY = 0.0;  // Current position
bool zCylinderExtended = false;       // Z-axis state (true = extended, false = retracted)
float feedRate = 1000.0;              // Default feed rate in mm/min
float acceleration = 200.0;           // Acceleration in mm/s²
bool isHomed = false;                 // Homing state

// Stop motion if limit switch is triggered
bool checkLimitSwitches() {
  if (digitalRead(X1_LIMIT_PIN) == LOW || digitalRead(Y1_LIMIT_PIN) == LOW || digitalRead(X2_LIMIT_PIN) == LOW|| digitalRead(Y2_LIMIT_PIN) == LOW) {
    Serial.println("Limit switch triggered!");
    return false;
  }
  return true;
}

// Move H-Bot motors with acceleration and deceleration
bool moveHBot(float deltaX, float deltaY) {
  Serial.println("Moving...");
  
  if (checkLimitSwitches()){

    int stepsA = deltaX + deltaY;
    int stepsB = deltaX - deltaY;

    bool dirA = (stepsA >= 0);
    bool dirB = (stepsB >= 0);

    digitalWrite(MOTOR_A_DIR_PIN, dirA ? HIGH : LOW);
    digitalWrite(MOTOR_B_DIR_PIN, dirB ? HIGH : LOW);

    stepsA = abs(stepsA);
    stepsB = abs(stepsB);

    int maxSteps = max(stepsA, stepsB);

    // Convert feed rate from mm/min to mm/s
    float targetSpeed = feedRate / 60.0;  // mm/s
    float stepDistance = 1.0 / maxSteps; // Distance per step
    float stepSpeed = 0.0;               // Current speed
    float timePerStep = 0.0;             // Time per step (s)

    // Acceleration phase
    for (int i = 0; i < maxSteps / 2; i++) {
      
      stepSpeed = min(targetSpeed, stepSpeed + acceleration * stepDistance);
      timePerStep = stepDistance / stepSpeed;

      digitalWrite(MOTOR_A_STEP_PIN, i < stepsA ? HIGH : LOW);
      digitalWrite(MOTOR_B_STEP_PIN, i < stepsB ? HIGH : LOW);

      delayMicroseconds(timePerStep * 1e6);

      digitalWrite(MOTOR_A_STEP_PIN, LOW);
      digitalWrite(MOTOR_B_STEP_PIN, LOW);
      delayMicroseconds(timePerStep * 1e6);
    }

    // Deceleration phase
    for (int i = maxSteps / 2; i < maxSteps; i++) {
      
      stepSpeed = max(acceleration * stepDistance, stepSpeed - acceleration * stepDistance);
      timePerStep = stepDistance / stepSpeed;

      digitalWrite(MOTOR_A_STEP_PIN, i < stepsA ? HIGH : LOW);
      digitalWrite(MOTOR_B_STEP_PIN, i < stepsB ? HIGH : LOW);
      delayMicroseconds(timePerStep * 1e6);

      digitalWrite(MOTOR_A_STEP_PIN, LOW);
      digitalWrite(MOTOR_B_STEP_PIN, LOW);
      delayMicroseconds(timePerStep * 1e6);
    }
    return true;
  }else{
    return false;
  }
}

// Control pneumatic cylinder for Z-axis
void controlZCylinder(bool extend) {
  zCylinderExtended = extend;
  digitalWrite(Z_SOLENOID_PIN, extend ? HIGH : LOW);
  Serial.println(extend ? "Z-axis: Cylinder extended." : "Z-axis: Cylinder retracted.");
}

// Perform homing (G28)
void homeAxes() {
  Serial.println("Homing axes...");

  // Home X and Y
  digitalWrite(MOTOR_A_DIR_PIN, LOW);
  digitalWrite(MOTOR_B_DIR_PIN, LOW);
  while (digitalRead(X1_LIMIT_PIN) == HIGH || digitalRead(Y1_LIMIT_PIN) == HIGH) {
    if (digitalRead(X1_LIMIT_PIN) == HIGH) digitalWrite(MOTOR_A_STEP_PIN, HIGH);
    if (digitalRead(Y1_LIMIT_PIN) == HIGH) digitalWrite(MOTOR_B_STEP_PIN, HIGH);

    delayMicroseconds(100);

    digitalWrite(MOTOR_A_STEP_PIN, LOW);
    digitalWrite(MOTOR_B_STEP_PIN, LOW);
    delayMicroseconds(100);
  }

  // Retract Z-axis to a known state
  controlZCylinder(false);

  // Reset positions
  currentX = -10.0;
  currentY = -10.0;

  isHomed = true;
  Serial.println("Homing complete.");
}

// Parse G-code
void parseGCode(String gcode) {
  gcode.trim();

  if (gcode.startsWith("G")) {
    int command = gcode.substring(1, gcode.indexOf(' ')).toInt();

    if (command == 0 || command == 1) {  // G0 or G1
      if (!isHomed) {
        Serial.println("Error: Machine not homed. Use G28 to home axes.");
        return;
      }

      float newX = currentX, newY = currentY;
      bool newZState = zCylinderExtended;  // Keep current state by default

      if (gcode.indexOf('X') != -1) newX = gcode.substring(gcode.indexOf('X') + 1).toFloat();
      if (gcode.indexOf('Y') != -1) newY = gcode.substring(gcode.indexOf('Y') + 1).toFloat();
      if (gcode.indexOf('Z') != -1) {
        float zValue = gcode.substring(gcode.indexOf('Z') + 1).toFloat();
        newZState = (zValue > 0);  // Positive Z = extend, negative/zero Z = retract
      }

      if (moveHBot(newX - currentX, newY - currentY)){
        currentX = newX;
        currentY = newY;
        Serial.print("Movement complete. New position: X=");
        Serial.print(currentX);
        Serial.print(", Y=");
        Serial.println(currentY);
      }else{
        Serial.println("Movement not complete");
        isHomed = false;
      }
      

      if (newZState != zCylinderExtended) {
        controlZCylinder(newZState);
      }

      
    } else if (command == 28) {  // G28
      homeAxes();
    } else {
      Serial.println("Error: Unknown G-code command: " + String(command));
    }
  } else if (gcode.startsWith("F")) {  // Feed rate
    float newFeedRate = gcode.substring(1).toFloat();
    if (newFeedRate > 0) {
      feedRate = newFeedRate;
      Serial.println("Feed rate set to " + String(feedRate) + " mm/min.");
    } else {
      Serial.println("Error: Invalid feed rate.");
    }
  } else if (gcode.startsWith("M")) {
    int command = gcode.substring(1, gcode.indexOf(' ')).toInt();

    if (command == 204) {  // M204 - Set acceleration
      float newAcceleration = gcode.substring(gcode.indexOf('S') + 1).toFloat();
      if (newAcceleration > 0) {
        acceleration = newAcceleration;
        Serial.println("Acceleration set to " + String(acceleration) + " mm/s².");
      } else {
        Serial.println("Error: Invalid acceleration value.");
      }
    } else if (command == 3) {  // M3 - Spindle ON
      digitalWrite(SPINDLE_PIN, HIGH);
    } else if (command == 5) {  // M5 - Spindle OFF
      digitalWrite(SPINDLE_PIN, LOW);
    } else {
      Serial.println("Error: Unknown M-code command: " + String(command));
    }
  } else {
    Serial.println("Error: Invalid command.");
  }
}

void setup() {
  // Initialize pins
  pinMode(MOTOR_A_STEP_PIN, OUTPUT);
  pinMode(MOTOR_A_DIR_PIN, OUTPUT);
  pinMode(MOTOR_B_STEP_PIN, OUTPUT);
  pinMode(MOTOR_B_DIR_PIN, OUTPUT);
  pinMode(Z_SOLENOID_PIN, OUTPUT);
  pinMode(SPINDLE_PIN, OUTPUT);

  pinMode(X1_LIMIT_PIN, INPUT_PULLDOWN);
  pinMode(Y1_LIMIT_PIN, INPUT_PULLDOWN);
  pinMode(X2_LIMIT_PIN, INPUT_PULLDOWN);
  pinMode(Y2_LIMIT_PIN, INPUT_PULLDOWN);

  // Initialize serial communication
  Serial.begin(115200);
  Serial.println("H-Bot G-code Interpreter Ready");
}

void loop() {
  // Check for incoming serial data
  if (Serial.available()) {
    String gcode = Serial.readStringUntil('\n');
    parseGCode(gcode);
  }
}
