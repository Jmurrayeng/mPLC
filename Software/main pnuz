#include <Arduino.h>

// Pin definitions (customize for your setup)
const int MOTOR_A_STEP_PIN = 2;
const int MOTOR_A_DIR_PIN = 3;
const int MOTOR_B_STEP_PIN = 4;
const int MOTOR_B_DIR_PIN = 5;
const int Z_SOLENOID_PIN = 6; // Solenoid valve for pneumatic cylinder
const int SPINDLE_PIN = 8;

const int X_LIMIT_PIN = 9;  // X-axis limit switch
const int Y_LIMIT_PIN = 10; // Y-axis limit switch

// Motion parameters
float currentX = 0.0, currentY = 0.0;  // Current position
bool zCylinderExtended = false;       // Z-axis state (true = extended, false = retracted)
float feedRate = 1000.0;              // Default feed rate (mm/min)
bool isHomed = false;                 // Homing state

// Stop motion if limit switch is triggered
void checkLimitSwitches() {
  if (digitalRead(X_LIMIT_PIN) == LOW || digitalRead(Y_LIMIT_PIN) == LOW) {
    Serial.println("Limit switch triggered! Stopping motion.");
    while (true) {
      delay(100);  // Halt indefinitely (or implement a reset mechanism)
    }
  }
}

// Move H-Bot motors
void moveHBot(float deltaX, float deltaY) {
  checkLimitSwitches();

  int stepsA = deltaX + deltaY;
  int stepsB = deltaX - deltaY;

  bool dirA = (stepsA >= 0);
  bool dirB = (stepsB >= 0);

  digitalWrite(MOTOR_A_DIR_PIN, dirA ? HIGH : LOW);
  digitalWrite(MOTOR_B_DIR_PIN, dirB ? HIGH : LOW);

  stepsA = abs(stepsA);
  stepsB = abs(stepsB);

  int maxSteps = max(stepsA, stepsB);
  for (int i = 0; i < maxSteps; i++) {
    if (i < stepsA) digitalWrite(MOTOR_A_STEP_PIN, HIGH);
    if (i < stepsB) digitalWrite(MOTOR_B_STEP_PIN, HIGH);

    delayMicroseconds(100);

    digitalWrite(MOTOR_A_STEP_PIN, LOW);
    digitalWrite(MOTOR_B_STEP_PIN, LOW);
    delayMicroseconds(100);
  }
}

// Control pneumatic cylinder for Z-axis
void controlZCylinder(bool extend) {
  zCylinderExtended = extend;
  digitalWrite(Z_SOLENOID_PIN, extend ? HIGH : LOW);
  Serial.println(extend ? "Z-axis: Cylinder extended." : "Z-axis: Cylinder retracted.");
}

// Perform homing (G28)
void homeAxes() {
  Serial.println("Homing axes...");

  // Home X and Y
  digitalWrite(MOTOR_A_DIR_PIN, LOW);
  digitalWrite(MOTOR_B_DIR_PIN, LOW);
  while (digitalRead(X_LIMIT_PIN) == HIGH || digitalRead(Y_LIMIT_PIN) == HIGH) {
    if (digitalRead(X_LIMIT_PIN) == HIGH) digitalWrite(MOTOR_A_STEP_PIN, HIGH);
    if (digitalRead(Y_LIMIT_PIN) == HIGH) digitalWrite(MOTOR_B_STEP_PIN, HIGH);

    delayMicroseconds(100);

    digitalWrite(MOTOR_A_STEP_PIN, LOW);
    digitalWrite(MOTOR_B_STEP_PIN, LOW);
    delayMicroseconds(100);
  }

  // Retract Z-axis to a known state
  controlZCylinder(false);

  // Reset positions
  currentX = 0.0;
  currentY = 0.0;

  isHomed = true;
  Serial.println("Homing complete.");
}

// Parse G-code
void parseGCode(String gcode) {
  gcode.trim();

  if (gcode.startsWith("G")) {
    int command = gcode.substring(1, gcode.indexOf(' ')).toInt();

    if (command == 0 || command == 1) {  // G0 or G1
      if (!isHomed) {
        Serial.println("Error: Machine not homed. Use G28 to home axes.");
        return;
      }

      float newX = currentX, newY = currentY;
      bool newZState = zCylinderExtended;  // Keep current state by default

      if (gcode.indexOf('X') != -1) newX = gcode.substring(gcode.indexOf('X') + 1).toFloat();
      if (gcode.indexOf('Y') != -1) newY = gcode.substring(gcode.indexOf('Y') + 1).toFloat();
      if (gcode.indexOf('Z') != -1) {
        float zValue = gcode.substring(gcode.indexOf('Z') + 1).toFloat();
        newZState = (zValue > 0);  // Positive Z = extend, negative/zero Z = retract
      }

      moveHBot(newX - currentX, newY - currentY);

      if (newZState != zCylinderExtended) {
        controlZCylinder(newZState);
      }

      currentX = newX;
      currentY = newY;
    } else if (command == 28) {  // G28
      homeAxes();
    } else {
      Serial.println("Error: Unknown G-code command: " + String(command));
    }
  } else if (gcode.startsWith("M")) {
    int command = gcode.substring(1).toInt();

    if (command == 3) {  // M3 - Spindle ON
      digitalWrite(SPINDLE_PIN, HIGH);
    } else if (command == 5) {  // M5 - Spindle OFF
      digitalWrite(SPINDLE_PIN, LOW);
    } else {
      Serial.println("Error: Unknown M-code command: " + String(command));
    }
  } else {
    Serial.println("Error: Invalid command.");
  }
}

void setup() {
  // Initialize pins
  pinMode(MOTOR_A_STEP_PIN, OUTPUT);
  pinMode(MOTOR_A_DIR_PIN, OUTPUT);
  pinMode(MOTOR_B_STEP_PIN, OUTPUT);
  pinMode(MOTOR_B_DIR_PIN, OUTPUT);
  pinMode(Z_SOLENOID_PIN, OUTPUT);
  pinMode(SPINDLE_PIN, OUTPUT);

  pinMode(X_LIMIT_PIN, INPUT_PULLUP);
  pinMode(Y_LIMIT_PIN, INPUT_PULLUP);

  // Initialize serial communication
  Serial.begin(115200);
  Serial.println("H-Bot G-code Interpreter Ready");
}

void loop() {
  // Check for incoming serial data
  if (Serial.available()) {
    String gcode = Serial.readStringUntil('\n');
    parseGCode(gcode);
  }
}