#include <AccelStepper.h>

// Pin definitions
const int MOTOR_A_STEP_PIN = 11;
const int MOTOR_A_DIR_PIN = 12;
const int MOTOR_B_STEP_PIN = 13;
const int MOTOR_B_DIR_PIN = 14;
const int Z_SOLENOID_PIN = 15; // Solenoid valve for pneumatic cylinder
const int SPINDLE_PIN = 16;

// Limit switch pins
const int X_LIMIT_PIN = 9;
const int Y_LIMIT_PIN = 10;

// Motion parameters
float currentX = 0.0, currentY = 0.0;  // Current position in mm
bool zCylinderExtended = false;       // Z-axis state (true = extended, false = retracted)
float stepsPerMM = 158.0;             // Adjust this based on your hardware (steps/mm)
float feedRate = 10.0;                // Default feed rate in steps/sec
bool isHomed = false;                 // Homing state

// Create AccelStepper objects for motors A and B
AccelStepper motorA(AccelStepper::DRIVER, MOTOR_A_STEP_PIN, MOTOR_A_DIR_PIN);
AccelStepper motorB(AccelStepper::DRIVER, MOTOR_B_STEP_PIN, MOTOR_B_DIR_PIN);

// Check limit switches and return true if all limits are OK
bool checkLimitSwitches() {
  if (digitalRead(X_LIMIT_PIN) == HIGH || digitalRead(Y_LIMIT_PIN) == HIGH) {
    Serial.println("Limit switch triggered! Motion aborted.");
    return false;
  }
  return true;
}

// Interpolated straight-line movement
bool moveLinear(float targetX, float targetY) {
  float deltaX = targetX - currentX;
  float deltaY = targetY - currentY;

  // Calculate total distance and steps
  float distance = sqrt(deltaX * deltaX + deltaY * deltaY);
  int steps = distance * stepsPerMM; // Total steps based on resolution

  // Calculate incremental movements
  float stepX = deltaX / steps;
  float stepY = deltaY / steps;

  // Move incrementally
  for (int i = 0; i < steps; i++) {
    if (!moveHBot(stepX, stepY)) {
      Serial.println("Error: Motion aborted during straight line.");
      return false;
    }
  }

  Serial.println("Linear movement complete.");
  return true;
}

// Arc movement (G2/G3)
void executeArc(float startX, float startY, float endX, float endY, float I, float J, bool isClockwise) {
  float centerX = startX + I;
  float centerY = startY + J;

  // Radius of the arc
  float radius = sqrt(I * I + J * J);

  // Start and end angles
  float startAngle = atan2(startY - centerY, startX - centerX);
  float endAngle = atan2(endY - centerY, endX - centerX);

  // Adjust angles for clockwise/counterclockwise movement
  if (isClockwise && endAngle > startAngle) endAngle -= 2 * PI;
  if (!isClockwise && endAngle < startAngle) endAngle += 2 * PI;

  // Divide the arc into segments
  int segments = 100;  // Adjust for precision
  float angleStep = (endAngle - startAngle) / segments;

  for (int i = 1; i <= segments; i++) {
    float angle = startAngle + i * angleStep;
    float targetX = centerX + radius * cos(angle);
    float targetY = centerY + radius * sin(angle);

    // Move incrementally
    if (!moveHBot(targetX - currentX, targetY - currentY)) {
      Serial.println("Error: Motion aborted during arc.");
      return;
    }
  }

  Serial.println("Arc movement complete.");
}

// Control pneumatic cylinder for Z-axis
void controlZCylinder(bool extend) {
  zCylinderExtended = extend;
  digitalWrite(Z_SOLENOID_PIN, extend ? HIGH : LOW);
}

// Perform homing (G28)
void homeAxes() {
  Serial.println("Homing axes...");

  // Move motors towards limit switches
  motorA.setSpeed(-100);
  motorB.setSpeed(-100);

  while (digitalRead(X_LIMIT_PIN) == HIGH || digitalRead(Y_LIMIT_PIN) == HIGH) {
    if (digitalRead(X_LIMIT_PIN) == HIGH) motorA.runSpeed();
    if (digitalRead(Y_LIMIT_PIN) == HIGH) motorB.runSpeed();
  }

  motorA.stop();
  motorB.stop();

  // Reset Z-axis and positions
  controlZCylinder(false);
  currentX = 0.0;
  currentY = 0.0;
  isHomed = true;
  Serial.println("Homing complete.");
}

// Parse G-code
void parseGCode(String gcode) {
  gcode.trim();

  if (gcode.startsWith("G")) {
    int command = gcode.substring(1, gcode.indexOf(' ')).toInt();

    if (command == 0 || command == 1) {  // G0 or G1
      if (!isHomed) {
        Serial.println("Error: Machine not homed. Use G28 to home axes.");
        return;
      }

      float newX = currentX, newY = currentY;
      if (gcode.indexOf('X') != -1) newX = gcode.substring(gcode.indexOf('X') + 1).toFloat();
      if (gcode.indexOf('Y') != -1) newY = gcode.substring(gcode.indexOf('Y') + 1).toFloat();

      if (!moveLinear(newX, newY)) {
        Serial.println("Error: Linear motion aborted.");
      }
    } else if (command == 2 || command == 3) {  // G2 or G3
      if (!isHomed) {
        Serial.println("Error: Machine not homed. Use G28 to home axes.");
        return;
      }

      float endX = currentX, endY = currentY;
      float centerI = 0.0, centerJ = 0.0;

      if (gcode.indexOf('X') != -1) endX = gcode.substring(gcode.indexOf('X') + 1).toFloat();
      if (gcode.indexOf('Y') != -1) endY = gcode.substring(gcode.indexOf('Y') + 1).toFloat();
      if (gcode.indexOf('I') != -1) centerI = gcode.substring(gcode.indexOf('I') + 1).toFloat();
      if (gcode.indexOf('J') != -1) centerJ = gcode.substring(gcode.indexOf('J') + 1).toFloat();

      executeArc(currentX, currentY, endX, endY, centerI, centerJ, command == 2);
    } else if (command == 28) {  // G28
      homeAxes();
    } else {
      Serial.println("Error: Unknown G-code command: " + String(command));
    }
  } else {
    Serial.println("Error: Invalid command.");
  }
}

void setup() {
  pinMode(Z_SOLENOID_PIN, OUTPUT);
  pinMode(SPINDLE_PIN, OUTPUT);
  pinMode(X_LIMIT_PIN, INPUT_PULLUP);
  pinMode(Y_LIMIT_PIN, INPUT_PULLUP);
  Serial.begin(115200);
  Serial.println("H-Bot G-code Interpreter Ready");

  motorA.setMaxSpeed(2000);
  motorB.setMaxSpeed(2000);
  motorA.setAcceleration(500);
  motorB.setAcceleration(500);
}

void loop() {
  if (Serial.available()) {
    String gcode = Serial.readStringUntil('\n');
    parseGCode(gcode);
  }
}